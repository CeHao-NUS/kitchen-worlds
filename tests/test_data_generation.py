#!/usr/bin/env python

from __future__ import print_function
import shutil

import os
import json
from os.path import join, abspath, dirname, isdir, isfile, basename
from config import EXP_PATH, OUTPUT_PATH

from pybullet_tools.pr2_utils import get_group_conf
from pybullet_tools.utils import disconnect, LockRenderer, has_gui, WorldSaver, wait_if_gui, \
    SEPARATOR, get_aabb, wait_for_duration
from pybullet_tools.bullet_utils import summarize_facts, print_goal, nice, get_datetime
from pybullet_tools.pr2_agent import solve_multiple, post_process, move_cost_fn
from pybullet_tools.logging import TXT_FILE

from pybullet_tools.pr2_primitives import get_group_joints, Conf, get_base_custom_limits, Pose, Conf, \
    get_ik_ir_gen, get_motion_gen, get_cfree_approach_pose_test, get_cfree_pose_pose_test, get_cfree_traj_pose_test, \
    get_grasp_gen, Attach, Detach, Clean, Cook, control_commands, Command, \
    get_gripper_joints, GripperCommand, State
from pybullet_tools.flying_gripper_agent import get_stream_map

from pddlstream.language.generator import from_gen_fn, from_list_fn, from_fn, fn_from_constant, empty_gen, from_test
from pddlstream.language.constants import Equal, AND, print_solution, PDDLProblem
from pddlstream.utils import read, INF, get_file_path, find_unique, Profiler, str_from_object
from pddlstream.algorithms.meta import solve, create_parser
from pddlstream.algorithms.focused import solve_focused

from pybullet_planning.lisdf_tools.lisdf_loader import load_lisdf_pybullet, pddlstream_from_dir
from pybullet_planning.lisdf_tools.lisdf_planning import pddl_to_init_goal, Problem

from world_builder.actions import apply_actions

from test_utils import parallel_processing
from test_world_builder import create_pybullet_world


DEFAULT_TEST = 'test_fridges_tables'
PARALLEL = False
DIVERSE = False


def get_args(test_name=DEFAULT_TEST, output_name='one_fridge_pick_pr2', n_problems=2,
             parallel=PARALLEL, diverse=DIVERSE):

    parser = create_parser()
    parser.add_argument('-test', type=str, default=test_name,
                        help='Name of a sub-dir in test_cases/ generated by cognitive-architectures')
    parser.add_argument('-output_dir', type=str, default=output_name,
                        help='Name of the output folder inside outputs/')
    parser.add_argument('-n_problems', type=int, default=n_problems,
                        help='Number of sampled problems (scene & goal)')
    parser.add_argument('-p', action='store_true', default=parallel)
    parser.add_argument('-d', action='store_true', default=diverse)

    parser.add_argument('-v', '--viewer', action='store_true', help='')
    parser.add_argument('-t', '--time_step', type=float, default=4e-0)
    parser.add_argument('-s', '--seed', type=int, default=None, help='')
    parser.add_argument('-cam', '--camera', action='store_true', default=True, help='')
    parser.add_argument('-cfree', action='store_true', help='Disables collisions during planning')
    parser.add_argument('-enable', action='store_true', help='Enables rendering during planning')
    parser.add_argument('-teleport', action='store_true', help='Teleports between configurations')
    # parser.add_argument('-simulate', action='store_true', help='Simulates the system')
    args = parser.parse_args()
    print('Arguments:', args)
    return args


args = get_args()


def init_data_run(test_name, data_name):
    """ inside each data folder, to be generated:
        - before planning:
            - scene.lisdf
            - problem.pddl
            - planning_config.json
            - log.txt (generated before planning)
        - after planning:
            - plan.json
            - commands.pkl
            - log.json (generated by pddlstream)
        - before training (optional):
            - crop_images
            - diverse_plans.json
            - features.txt
    """
    testcase_dir = join(EXP_PATH, test_name)
    output_dir = join(OUTPUT_PATH, data_name)
    if isdir(testcase_dir):
        os.mkdir(output_dir)
        for f in ['domain.pddl', 'domain_full.pddl', 'stream.pddl']:
            shutil.copy(join(testcase_dir, f), join(output_dir, f))


def get_builder(test_name):
    from world_builder.builders import test_one_fridge as test_scene
    if test_name == 'test_one_fridge':
        from world_builder.builders import test_one_fridge as test_scene
    elif test_name == 'test_fridge_table':
        from world_builder.builders import test_fridge_table as test_scene
    elif test_name == 'test_fridges_tables':
        from world_builder.builders import test_fridges_tables as test_scene
    return test_scene

#####################################


def process(output_dir):
    """ exist a version in cognitive-architectures for generating mini-datasets (single process),
        run in kitchen-worlds for parallelization, but no reliable planning time data """

    """ STEP 0 -- INITIATE THE EXPERIMENT """
    # init_data_run(args.test, output_dir)

    """ STEP 1 -- GENERATE SCENES """
    file, state, goal = create_pybullet_world(args, get_builder(args.test), world_name=basename(output_dir),
                                              template_name=args.test, out_dir=output_dir, verbose=False,
                                              SAVE_LISDF=False, SAVE_TESTCASE=True, to_plan=True)
    world = state.world
    saver = WorldSaver()
    problem = Problem()

    pddlstream_problem = pddlstream_from_dir(problem, exp_dir=output_dir, collisions=not args.cfree,
                                             teleport=args.teleport)
    _, _, _, stream_map, init, goal = pddlstream_problem
    world.summarize_all_objects(init)

    # stream_info = get_stream_info(partial=False, defer=False)  ## problem
    summarize_facts(init, world=world)
    print_goal(goal)
    print(SEPARATOR)

    stream_info = world.robot.get_stream_info(partial=False, defer=False)

    kwargs = dict()
    if args.diverse:
        kwargs = dict(
            diverse=True,
            downward_time=20,  ## max time to get 100, 10 sec, 30 sec for 300
            evaluation_time=60,  ## on each skeleton
            max_plans=200,  ## number of skeletons
        )
    solution, tmp_dir = solve_multiple(pddlstream_problem, stream_info, lock=not args.enable, **kwargs)

    print_solution(solution)
    plan, cost, evaluations = solution
    if (plan is None) or not has_gui():
        disconnect()
        return

    print(SEPARATOR)
    with LockRenderer(lock=not args.enable):
        commands = post_process(problem, plan)
        problem.remove_gripper()
        saver.restore()

    saver.restore()
    wait_if_gui('Execute?')
    if args.simulate:  ## real physics
        control_commands(commands)
    else:
        # apply_commands(State(), commands, time_step=0.01)
        apply_actions(problem, commands, time_step=0.1)
    wait_if_gui('Finish?')
    disconnect()


def collect_for_fastamp():
    start = get_datetime()
    output_dirs = [join(args.output_dir, f'{start}_{i}') for i in range(args.n_problems)]
    parallel_processing(process, output_dirs, parallel=args.p)


if __name__ == '__main__':
    collect_for_fastamp()
